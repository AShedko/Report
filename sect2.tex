\section{Модификация проекта «Интерпретатор арифметических выражений»}

\subsection{Постановка задачи:}
Вычисляются значения выражений, содержащих битовые операциями  $<<$ и $>>$,
приоритет первой из которых является минимальным, а второй — максимальным.

\subsection{Теоретические аспекты:}
Если компилятор осуществляет перевод с одного языка на другой, то интерпретатор
\emph{вычисляет} значение арифметической формулы, в которой вместо имён переменных
содержатся записанные тем или иным способом числа.

Для решения задачи требуется учесть приоритет оператора сдвига вправо, а потому
граматика $G_0$ из предыдущего пункта должна быть изменена:

$G_0$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rcccccll}
$S_0 \rightarrow$ & $F $&$\mid$&$ S~L~F$\\
$F \rightarrow$ & $T $&$\mid$&$ F+T$&$\mid$&$ F-T$\\
$T \rightarrow$ & $M $&$\mid$&$ T*M$&$\mid$&$ T~/~M$\\
$S_1 \rightarrow$ & $M $&$\mid$&$ S~R~F$\\
$M \rightarrow$ & $(S_0)$&$\mid$&$ V$\\
$V \rightarrow$ & a &$\mid$& b &$\mid$& \dots &$\mid$& z\\
\end{tabular}
\medskip

$S_0$ --- Класс сдивгаемых влево выражений;
$S_1$ --- Класс сдивгаемых вправо выражений

$G_s$ можно оставить без изменений.

Построенный класс Compf можно использовать в качестве базового для реализации
интерпретатора арифметических выражений. Подобный подход является характерной
особенностью объектно-ориентированного программирования — уже написанный код можно
применить для решения родственной задачи без каких-либо его изменений.

Интерпретатор выражений отличает от компилятора формул два момента: наличие во
входной формуле \emph{чисел} (вместо идентификаторов переменных) и необходимость
\emph{выполнения} получаемой выходной формулы (вместо её печати). Для того чтобы
реализовать стековый калькулятор, естественно, необходим стек.

При появлении на входе цифры, будем помещать её в стек калькулятора \verb|@s|,
а при появлении операции, доставать из стека её аргументы и помещать туда результат
её выполнения. На конечном этапе на вершине стека будет находиться результат
выполнения арифметическкого выражения.

\subsection{Детали реализации}
Здесь также как и в первом проекте применена хеш-таблица для отображения множества
операций стекового компилятора в множеество операций языка ruby.
\begin{lstlisting}
  CONV_TABLE = {'R'=>">>" ,
              'L'=>"<<",
              "+"=>"+",
              "-"=>"-",
              "/"=>"/",
              "*"=>"*"
            }
\end{lstlisting}
В соответствии с задачей, приоритет операций был изменён следующим образом:
\begin{lstlisting}
  def priority(c)
    (c == '+' or c == '-') ? 1 : c=='L' ? 0 : (c=='R') ? 3 : 2
  end
\end{lstlisting}

\begin{table}[ht!]
\caption{Приоритет операций}
\begin{center}
\begin{tabular}{cc}
\hline
Операция&Приоритет\\
\hline
$L$&$0$\\
$+,-$&$1$\\
$*,/$&$2$\\
$R$&$3$\\
\hline
\end{tabular}
\end{center}
\end{table}
