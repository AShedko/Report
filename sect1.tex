
\section{Модификация проекта «Компилятор формул»}
\subsection{Постановка задачи:}
В предположении, что язык стекового калькулятора
расширен операциями L (left) и R (right),
реализующими побитовый сдвиг влево и вправо соответственно, компилировать
формулы, содержащие операции \verb|<<| и \verb|>>|.

\subsection{Теоретические аспекты:}
С формальной точки зрения компилятор представляет собой программную реализацию
некоторой функции $\tau\colon L_1 \rightarrow L_2$, действующей из множества
цепочек одного языка $L_1$ в множество цепочек другого $L_2$ таким образом, что
$\forall \omega \in L_1$ {\em семантика цепочек $\omega$ и $\tau(\omega)\in L_2$
 совпадает.}

Для решения задачи необходимо задать грамматики, описывающие языки стекового
калькулятора и компилятора, соответственно $G_0$ и $G_s$:

$G_0$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rcccccll}
\verb|S| $\rightarrow$ & \verb|F| &$\mid$& \verb|SRF|&$\mid$&\verb|SLF|\\
\verb|F| $\rightarrow$ & \verb|T| &$\mid$& \verb|F+T|&$\mid$&\verb|F-T|\\
\verb|T| $\rightarrow$ & \verb|M| &$\mid$& \verb|T*M|&$\mid$&\verb|T/M|\\
\verb|M| $\rightarrow$ & \verb|(S)|&$\mid$& \verb|V|\\
\verb|V| $\rightarrow$ & a &$\mid$& b &$\mid$& \dots &$\mid$& z\\
\end{tabular}
\medskip

$G_s$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rll}
$e\rightarrow$ & $e~e~+ \mid e~e~-\mid e~e~* \mid e~e~/ \mid e~e~>>\mid e~e~<<\mid$\\
&$\mid a \mid b \mid \dots \mid z$
\end{tabular}

\noindent{где $L$, $R$ соответствуют \verb|<<|, \verb|>>|, т.е. сдвигу влево и вправо,
а $S$ --- классу сдвигаемых выражений (ассоциативность аналогична \verb|+| и \verb|-|)}.

Нужный нам компилятор $\tau$ представляет собой программную реализацию отображения из
множества цепочек языка $L(G_0)$ в множество цепочек языка $L(G_s)$ По этой причине его можно
рассматривать, как функцию на пространстве последовательностей. Легко понять,
что эта функция не индуктивна.

Построим индуктивное расширение  функции  чтобы с его помощью реализовать
однопроходный алгоритм, осуществляющий нужный нам перевод. Заметим, что любую
правильную формулу можно откомпилировать с соблюдением следующих двух условий:
\begin{itemize}
\item переменные в выходной цепочке (программе для стекового калькулятора) будут идти
в том же порядке, что и переменные в исходной формуле;
\item все операции в выходной цепочке будут расположены позже соответствующих им
операций в исходной формуле.
\end{itemize}

Любую формулу можно компилировать так: встретив имя переменной, немедленно
записывать его в массив, где мы будем накапливать результат компиляции, а
встретив знак операции или скобку, записывать в этот массив те из предыдущих,
но ещё не обработанных операций (будем называть их \emph{отложенными}), которые
выполнимы в данный момент, после чего «откладывать» и новый знак.

В качестве контейнера для хранения отложенных операций можно использовать стек.
Этот стек и будет содержать ту дополнительную информацию, которая необходима для
индуктивного перевычисления функции $T$ осуществляющей компиляцию исходной формулы.
Основная проблема — понять, что надо делать, когда в исходной формуле встречается
очередная операция или скобка.

Таким образом, встретив в исходной формуле очередной знак операции или скобку,
нужно иногда просто положить её в стек отложенных операций, а иногда — извлечь
предварительно одну или несколько ранее отложенных операций и добавить их в
массив результата. С точки зрения теории индуктивных функций необходимо построить
индуктивное расширение функции $T$ осуществляющей компиляцию исходной формулы, и
найти для неё отображение $G$ обеспечивающее её перевычисление при удлинении входной формулы.

Для построения индуктивной функции компиляции цепочки $\omega$ необходимо разделить
символы на категории: \verb|SYM_LEFT, SYM_RIGHT, SYM_OPER и SYM_OTHER| соответственно.
правила построения таковы:
\begin{itemize}
  \item открывающую скобку всегда помещать в стек, имя переменной --- всегда
  сразу добавлять в массив результата компиляции;
  \item когда в формуле встречается закрывающая скобка нужно все операции,
  появившиеся в ней \emph{после соответствующей ей открывающей скобки}, извлечь
  из стека отложенных операций и добавить в массив результата
  (не забыть также извлечь открывающую скобку);
  \item операции и скобки помещаются в стек в соответствии с приоритетом
  соответствующей операции или скобке. Открывающие скобки имеют наименьший приоритет,
  закрывающие~--- наибольший; для операций он будет описан в дальнейшем.
\end{itemize}
Более подробно см. \cite{compf}

\subsection{Применяемые структуры данных}
Стек, используемый в эталонном проекте не требует пояснений.
Помимо стека используется константная хэш-таблица (в качестве отображения
между множествами операций двух грамматик). Подробно с работой хеш-таблицы в языке
Ruby можно ознакомиться в документации к языку~\cite{rubydoc} и на соответствующей
странице Википедии.

\subsection{Детали реализации}

Отображение между множествами операций языков калькулятора и компилятора описывается
данной таблицей.
\begin{lstlisting}
CONV_TABLE = {">>" => "R",
              "<<" => "L",
               "+" => "+",
               "-" => "-",
               "/" => "/",
               "*" => "*"}
\end{lstlisting}

Приоритет операций задаётся следующим образом:
\begin{lstlisting}
def priority(c)
  (c == '+' or c == '-') ? 1 : ( c=='L' or c=='R' )? 0 : 2
end
\end{lstlisting}

Этот фрагмент кода устанавливает наименьший приоритет для сдвигов~($0$) и наивысший для
деления и умножения~($2$).

Наиболее значительным является изменение, касающееся обработки символов операций,
а именно обработка символов \verb|>>| и \verb|<<| так как они занимают два
строковых символа,являясь одним логическим символом. Идея проста --- хранить
первый символ в обрабатываемой последовательности соответствующий одной из
операций в специальной переменной \verb|@op|, а при поступлении следующего
символа, если последовательность составлена верно и этот символ совпадает с
\verb|<| или \verb|>|, записывать его в \verb|@op|. После этого, вне зависимости
от содержимого \verb|@op| происходит стандартная процедура обработки отложенных
операций с использованием значения \verb|CONV_TABLE[@op]|, которое затем
помещается в стек. В конце \verb|@op| очищается.

\newpage

Код, реализующий обработку символов операций:
\begin{lstlisting}
def process_symbol(c)
  ...
  when SYM_OPER
    if ((c=='>'||c=='<')&&@op=="")
      @op=c
    else
      @op+=c
      process_suspended_operators(CONV_TABLE[@op])
      push(CONV_TABLE[@op])
      @op=""
  end
  ...
end
\end{lstlisting}

Таким образом в язык стекового компилятора добавлена операция побитового сдвига.
\subsection{Возможные обобщения}
Имеет смысл ввести в язык стекового компилятора также остальные побитовые операции~$\left(\&,|,\verb|^,~|\right)$, их логические аналоги~$\left(\&\&,\|\|\right)$.
