
\section{Модификация проекта «Компилятор формул»}
\subsection{Постановка задачи:}
В предположении, что язык стекового калькулятора
расширен операциями L (left) и R (right),
реализующими побитовый сдвиг влево и вправо соответственно, компилировать
формулы, содержащие операции \verb|<<| и \verb|>>|

\subsection{Теоретические аспекты:}
С формальной точки зрения компилятор представляет собой программную реализацию
некоторой функции $\tau\colon L_1 \rightarrow L_2$, действующей из множества
цепочек одного языка $L_1$ в множество цепочек другого $L_2$ таким образом, что
$\forall \omega \in L_1$ {\em семантика цепочек $\omega$ и $\tau(\omega)\in L_2$
 совпадает.}

Для решения задачи необходимо задать грамматики, описывающие языки стекового
калькулятора и компилятора, соответственно $G_0$ и $G_s$:

$G_0$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rlllllllll}
$S \rightarrow$ & $F $&$\mid$&$ S~R~F$&$\mid$&$ S~L~F$\\
$F \rightarrow$ & $T $&$\mid$&$ F+T$&$\mid$&$ F-T$\\
$T \rightarrow$ & $M $&$\mid$&$ T*M$&$\mid$&$ T~/~M$\\
$M \rightarrow$ & $(S)$&$\mid$ V\\
$V \rightarrow$ & a $\mid$ b $\mid$ c $\mid$ \dots $\mid$ z\\
\end{tabular}
\medskip

$G_s$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rll}
$e\rightarrow$ & $e~e~+ \mid e~e~-\mid e~e~* \mid e~e~/ \mid e~e~>>\mid e~e~<<\mid$\\
&$\mid a \mid b \mid \dots \mid z$
\end{tabular}

 где $L$, $R$ соответсвуют \verb|<<|, \verb|>>|, т.е. сдвигу влево и вправо,
 а $S$ --- классу сдвигаемых выражений (Ассоциативность аналогична $+$ и $-$)

Нужный нам компилятор $\tau$ представляет собой программную реализацию отображения из
множества цепочек языка $L(G_0)$ в множество цепочек языка $L(G_s)$ По этой причине его можно
рассматривать, как функцию на пространстве последовательностей. Легко понять,
что эта функция не индуктивна.

Построим индуктивное расширение  функции  чтобы с его помощью реализовать
однопроходный алгоритм, осуществляющий нужный нам перевод. Заметим, что любую
правильную формулу можно откомпилировать с соблюдением следующих двух условий:
\begin{itemize}
\itemпеременные в выходной цепочке (программе для стекового калькулятора) будут идти
в том же порядке, что и переменные в исходной формуле;
\itemвсе операции в выходной цепочке будут расположены позже соответствующих им
операций в исходной формуле.
\end{itemize}

Любую формулу можно компилировать так: встретив имя переменной, немедленно
записывать его в массив, где мы будем накапливать результат компиляции, а
встретив знак операции или скобку, записывать в этот массив те из предыдущих,
но ещё не обработанных операций (будем называть их \emph{отложенными}), которые
выполнимы в данный момент, после чего «откладывать» и новый знак.

В качестве контейнера для хранения отложенных операций можно использовать стек.
Этот стек и будет содержать ту дополнительную информацию, которая необходима для
индуктивного перевычисления функции $T$ осуществляющей компиляцию исходной формулы.
Основная проблема — понять, что надо делать, когда в исходной формуле встречается
очередная операция или скобка.

Таким образом, встретив в исходной формуле очередной знак операции или скобку,
нужно иногда просто положить её в стек отложенных операций, а иногда — извлечь
предварительно одну или несколько ранее отложенных операций и добавить их в
массив результата. С точки зрения теории индуктивных функций необходимо построить
индуктивное расширение функции $T$ осуществляющей компиляцию исходной формулы, и
найти для неё отображение $G$ обеспечивающее её перевычисление при удлинении входной формулы.

Для построения индуктивной функции компиляции цепочки $\omega$ необходимо разделить
символы на категории: \verb|SYM_LEFT, SYM_RIGHT, SYM_OPER и SYM_OTHER| соответственно.
правила построения таковы:
\begin{itemize}
  \item открывающую скобку всегда помещать в стек, имя переменной --- всегда
  сразу добавлять в массив результата компиляции.
  \item Когда в формуле встречается закрывающая скобка нужно все операции,
  появившиеся в ней \emph{после соответствующей ей открывающей скобки}, извлечь
  из стека отложенных операций и добавить в массив результата.
  (не забыть также извлечь открывающую скобку)
  \item операции и скобки помещаются в стек в соответствии с приоритетом
  соответствующей операции или скобке. Открывающие скобки имеют наименьший приоритет,
  закрывающие --- наибольший; для операций он будет описан в дальнейшем.
\end{itemize}
Более подробно см. \cite{compf}

\subsection{Применяемые структуры данных}
Стек, используемый в эталонном проекте не требует пояснений.
Помимо стека используется константная хэш-таблица.(В качестве отображения
между множествами оперций двух грамматик). Подробно с раюотой хеш таблицы в языке
Ruby можно ознакомиться в документации к языку \cite{rubydoc} и на соответствующей
странице википедии.

\subsection{Детали реализации}

Отображение между множествами оперций языков калькулятора и компилятора описывается
данной таблицей.
\begin{lstlisting}
  CONV_TABLE = {">>" => 'R',
                "<<" => 'L',
                "+"=>"+",
                "-"=>"-",
                "/"=>"/",
                "*"=>"*"
              }
\end{lstlisting}

Приоритет операций задаётся следующим образом:
\begin{lstlisting}
def priority(c)
  (c == '+' or c == '-') ? 1 : ( c=='L' or c=='R' )? 0 : 2
end
\end{lstlisting}
что соответствует наименьшему приоритету для сдвигов($0$) и наивысшему для
деления и умножения($2$).

Наиболее значительным является изменение, касающееся обработки символов операций,
а именно обработка символов \verb|>>| и \verb|<<| так как они занимают два
строковых символа,являсь одним логическим символом. Идея проста --- хранить
первый симввол в обрабатываемой последовательности соответствующий одной из
операций в специальной переменной \verb|@op|, а при поступлении следующего
символа, если последовательность составлена верно и этот символ совпадает с
\verb|<| или \verb|>|, записывать его в \verb|@op|. После этого, вне зависимости
от содержимого \verb|@op| происходит стандартная процедура обработки отложенных
операций с использованием значения \verb|CONV_TABLE[@op]|, которое затем
помещается в стек. В конце \verb|@op| очищается.

\newpage

Код, реализующий обработку символов операций:
\begin{lstlisting}
def process_symbol(c)
  ...
  when SYM_OPER
    if ((c=='>'||c=='<')&&@op=="")
      @op=c
    else
      @op+=c
      process_suspended_operators(CONV_TABLE[@op])
      push(CONV_TABLE[@op])
      @op=""
  end
  ...
end
\end{lstlisting}

Таким образом в язык стекового компилятора добавлена операция побитового сдвига.
\subsection{Возможные обобщения}
Имеет смысл ввести в язык стекового компилятора также остальные побитовые операции,
$\&,|,\verb|^,~|$, их логические аналоги ($\&\&,\|\|$).
