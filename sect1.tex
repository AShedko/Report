\section{Модификация проекта «Компилятор формул»}

\subsection{Постановка задачи:}
В предположении, что язык стекового калькулятора
расширен операциями L (left) и R (right),
реализующими побитовый сдвиг влево и вправо соответственно, компилировать
формулы, содержащие операции $<<$ и $>>$

\subsection{Теоретические аспекты:}
С формальной точки зрения компилятор представляет собой программную реализацию
некоторой функции $\tau\colon L_1 \rightarrow L_2$, действующей из множества
цепочек одного языка $L_1$ в множество цепочек другого $L_2$ таким образом, что
$\forall \omega \in L_1$ {\em семантика цепочек $\omega$ и $\tau(\omega)\in L_2$
 совпадает.}

Для решения задачи необходимо задать грамматики, описывающие языки стекового
калькулятора и компилятора, соответственно $G_0$ и $G_s$:

$G_0$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rlllllllll}
$S \rightarrow$ & $F $&$\mid$&$ S~R~F$&$\mid$&$ S~L~F$\\
$F \rightarrow$ & $T $&$\mid$&$ F+T$&$\mid$&$ F-T$\\
$T \rightarrow$ & $M $&$\mid$&$ T*M$&$\mid$&$ T~/~M$\\
$M \rightarrow$ & $(S)$&$\mid$ V\\
$V \rightarrow$ & a $\mid$ b $\mid$ c $\mid$ \dots $\mid$ z\\
\end{tabular}
\medskip

$G_s$:
\medskip
\noindent\hspace{2cm}
\begin{tabular}{rll}
$e\rightarrow$ & $e~e~+ \mid e~e~-\mid e~e~* \mid e~e~/ \mid e~e~>>\mid e~e~<<\mid$\\
&$\mid a \mid b \mid \dots \mid z$
\end{tabular}

 где $L$, $R$ соответсвуют $<<$, $>>$, т.е. сдвигу влево и вправо,
 а $S$ --- классу сдвигаемых выражений (Ассоциативность аналогична $+$ и $-$)

Нужный нам компилятор $\tau$ представляет собой программную реализацию отображения из
множества цепочек языка $L(G_0)$ в множество цепочек языка $L(G_s)$ По этой причине его можно
рассматривать, как функцию на пространстве последовательностей. Легко понять,
что эта функция не индуктивна.

Построим индуктивное расширение  функции  чтобы с его помощью реализовать
однопроходный алгоритм, осуществляющий нужный нам перевод. Заметим, что любую
правильную формулу можно откомпилировать с соблюдением следующих двух условий:
\begin{itemize}
\itemпеременные в выходной цепочке (программе для стекового калькулятора) будут идти
в том же порядке, что и переменные в исходной формуле;
\itemвсе операции в выходной цепочке будут расположены позже соответствующих им
операций в исходной формуле.
\end{itemize}

Любую формулу можно компилировать так: встретив имя переменной, немедленно
записывать его в массив, где мы будем накапливать результат компиляции, а
встретив знак операции или скобку, записывать в этот массив те из предыдущих,
но ещё не обработанных операций (будем называть их \emph{отложенными}), которые
выполнимы в данный момент, после чего «откладывать» и новый знак.

В качестве контейнера для хранения отложенных операций можно использовать стек.
Этот стек и будет содержать ту дополнительную информацию, которая необходима для
индуктивного перевычисления функции $T$ осуществляющей компиляцию исходной формулы.
Основная проблема — понять, что надо делать, когда в исходной формуле встречается
очередная операция или скобка.

Таким образом, встретив в исходной формуле очередной знак операции или скобку,
нужно иногда просто положить её в стек отложенных операций, а иногда — извлечь
предварительно одну или несколько ранее отложенных операций и добавить их в
массив результата. С точки зрения теории индуктивных функций необходимо построить
индуктивное расширение функции $T$ осуществляющей компиляцию исходной формулы, и
найти для неё отображение $G$ обеспечивающее её перевычисление при удлинении входной формулы.

Для построения индуктивной функции компиляции цепочки $\omega$ необходимо разделить
символы на категории: \verb|SYM_LEFT, SYM_RIGHT, SYM_OPER и SYM_OTHER| соответственно.
правила построения таковы:
\begin{itemize}
  \item открывающую скобку всегда помещать в стек, имя переменной --- всегда
  сразу добавлять в массив результата компиляции.
  \item Когда в формуле встречается закрывающая скобка нужно все операции,
  появившиеся в ней \emph{после соответствующей ей открывающей скобки}, извлечь
  из стека отложенных операций и добавить в массив результата.
  (не забыть также извлечь открывающую скобку)
  \item операции и скобки помещаются в стек в соответствии с приоритетом
  соответствующей операции.(Будет описан в дальнейшем)
\end{itemize}

\subsection{Применяемые структуры данных}
Стек, используемый в эталонном проекте не требует пояснений.
Помимо стека используется константная хэш-таблица.(В качестве отображения
между множествами оперций двух грамматик). Подробно с раюотой хеш таблицы в языке
Ruby можно ознакомиться в документации к языку и на соответствующей странице
википедии.
\subsection{Детали реализации}
Отображение между множествами оперций языков калькулятора и компилятора описывается
данной таблицей.
\begin{lstlisting}
  CONV_TABLE = {">>" => 'R',
                "<<" => 'L',
                "+"=>"+",
                "-"=>"-",
                "/"=>"/",
                "*"=>"*"
              }
\end{lstlisting}

Приоритет операций задаётся следующим образом:
\begin{lstlisting}
def priority(c)
  (c == '+' or c == '-') ? 1 : ( c=='L' or c=='R' )? 0 : 2
end
\end{lstlisting}


Здесь следует описать:
\begin{enumerate}[1]
\item описание используемых структур данных и применяемых алгоритмов;
\item возможные обобщения рассматриваемой задачи (не обязательно, но
      весьма желательно).
\end{enumerate}
